package main

import (
	"fmt"
	"os"
	"os/signal"
	"syscall"
)

/* Реализовать постоянную запись данных в канал (главный поток).
Реализовать набор из N воркеров, которые читают произвольные данные из канала
и выводят в stdout. Необходима возможность выбора количества воркеров при старте.

Программа должна завершаться по нажатию Ctrl+C. Выбрать и обосновать способ завершения работы всех воркеров. */

func main() {
	//создаём три канала: ch для записи данных в главном потоке, sign для получения сигнала от ОС,
	// die для получения сигнала главной горутине о том, что пора закрывать канал и выходить из программы.
	ch := make(chan int)
	sign := make(chan os.Signal, 1)
	die := make(chan struct{})
	//используем сигнал SIGINT (отправляется при нажатии Ctrl+C) для отправления в канал sign
	signal.Notify(sign, syscall.SIGINT)
	//Задаём количество воркеров в программе
	var n int
	fmt.Println("Введите количество воркеров:")
	fmt.Scan(&n)
	//Запускаем наших воркеров
	for i := 1; i <= n; i++ {
		go worker(i, ch)
	}

	//в отдельной горутине ждём сигнала от пользователя, что пора завершать работу программы
	go func() {
		for {
			select {
			case <-sign:
				//при получении сигнала от пользователя отправляем сигнал главной горутине о прекращении записи
				//в канал, его закрытии и выхода из программы
				fmt.Println("Signal interrupt triggered.")
				die <- struct{}{}
			default:
				continue
			}
		}

	}()

	//В главной горутине пишем произвольные данные в канал ch до тех пор,
	//пока не придёт сигнала из канала die. В этом случае закрываем канал, и завершаем работу программы.
	for i := 1; i > 0; i++ {
		select {
		case <-die:
			close(ch)
			fmt.Println("Выхожу из программы")
			os.Exit(0)
		default:
			ch <- i
		}

	}

}

//функция воркер, которая читает из канала ch данные при их наличии
func worker(id int, ch <-chan int) {
	for {
		if v, ok := <-ch; ok {
			fmt.Println("worker", id, "read the value", v)
		}
	}
}
